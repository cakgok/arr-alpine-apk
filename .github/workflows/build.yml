name: Auto-build arr APKs

on:
  schedule:
    - cron: '0 5 * * *'
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Specific app to build'
        type: choice
        default: all
        options:
          - all
          - bazarr
          - sonarr
          - radarr
          - prowlarr

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

env:
  ARCHES: '["x86_64", "aarch64"]'
  APPS_CONFIG: |
    {
      "bazarr": {
        "upstream": "morpheus65535/bazarr",
        "description": "Subtitle management"
      },
      "sonarr": {
        "upstream": "Sonarr/Sonarr",
        "description": "TV series management"
      },
      "radarr": {
        "upstream": "Radarr/Radarr",
        "description": "Movie management"
      },
      "prowlarr": {
        "upstream": "Prowlarr/Prowlarr",
        "description": "Indexer management"
      }
    }

jobs:
  detect-updates:
    runs-on: ubuntu-latest
    outputs:
      apps_matrix: ${{ steps.check-apps.outputs.apps_matrix }}
      has_updates: ${{ steps.check-apps.outputs.has_updates }}
    
    steps:
    - uses: actions/checkout@v4
      with:
#       token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Check for app updates
      id: check-apps
      env:
        SELECTED_APP: ${{ inputs.app_name }} 
      run: bash ./scripts/check-apps.sh

  # Update APKBUILDs and commit changes
  update-apkbuilds:
    needs: detect-updates
    if: needs.detect-updates.outputs.has_updates == 'true'
    runs-on: ubuntu-latest

    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}-apkbuild-commit
      cancel-in-progress: false

    strategy:
      matrix:
        include: ${{ fromJSON(needs.detect-updates.outputs.apps_matrix) }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Update APKBUILD for ${{ matrix.app }}
      run: |
        set -e
        
        apkbuild_path="${{ matrix.app }}/APKBUILD"
        new_version="${{ matrix.version }}"
        
        echo "Updating $apkbuild_path to version $new_version"
        
        # Update version and reset release number
        sed -Ei "s/^pkgver=.*/pkgver=$new_version/" "$apkbuild_path"
        sed -Ei "s/^pkgrel=.*/pkgrel=0/" "$apkbuild_path"
        
        # Update checksums using Alpine container
        docker run --rm -v "$PWD/${{ matrix.app }}":/work -w /work alpine:edge sh -c '
          apk add --no-cache alpine-sdk
          abuild checksum
        '

    - name: Commit changes for ${{ matrix.app }}
      run: |
        git config user.name "CI Bot"
        git config user.email "ci@users.noreply.github.com"
        
        git add "${{ matrix.app }}/APKBUILD"
        git commit -m "${{ matrix.app }}: bump to v${{ matrix.version }}"
        
        # Create an annotated tag
        git tag -a "${{ matrix.app }}-v${{ matrix.version }}" -m "Release ${{ matrix.app }} v${{ matrix.version }}"
        
        # Explicitly push the branch and the new tags
        git push origin HEAD:${{ github.ref_name }} --follow-tags

  # Build APKs for updated apps
  build-apks:
    needs: [detect-updates, update-apkbuilds]
    if: needs.detect-updates.outputs.has_updates == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app_data: ${{ fromJSON(needs.detect-updates.outputs.apps_matrix) }}
        arch: ${{ fromJSON(env.ARCHES) }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        ref: ${{ matrix.app_data.app }}-v${{ matrix.app_data.version }}
        fetch-depth: 0

    - name: Enable multi-arch emulation
      uses: docker/setup-qemu-action@v3

    - name: Validate secrets
      run: |
        if [ -z "${{ secrets.ABUILD_KEY_NAME }}" ] || [ -z "${{ secrets.ABUILD_PRIVATE_KEY }}" ]; then
          echo "Missing required secrets: ABUILD_KEY_NAME and ABUILD_PRIVATE_KEY"
          exit 1
        fi

    - name: Build APK for ${{ matrix.app_data.app }} on ${{ matrix.arch }}
      env:
        KEY_NAME: ${{ secrets.ABUILD_KEY_NAME }}
        PRIVATE_KEY: ${{ secrets.ABUILD_PRIVATE_KEY }}
        ARCH: ${{ matrix.arch }}
        APP_NAME: ${{ matrix.app_data.app }}
      run: |
        set -eux
        
        # Map GitHub runner arch to Docker platform
        case "$ARCH" in
          x86_64) DOCKER_ARCH=amd64 ;;
          aarch64) DOCKER_ARCH=arm64 ;;
          *) DOCKER_ARCH=$ARCH ;;
        esac
        
        docker run --rm \
          --platform=linux/${DOCKER_ARCH} \
          -e KEY_NAME -e PRIVATE_KEY \
          -v "$PWD/${APP_NAME}":/work -w /work \
          alpine:edge sh -euxo pipefail -c '
            apk add --no-cache alpine-sdk
            
            # Setup abuild environment
            mkdir -p /root/.abuild
            echo "$PRIVATE_KEY" > /root/.abuild/$KEY_NAME
            chmod 600 /root/.abuild/$KEY_NAME
            
            # Extract and install public key
            openssl rsa -in /root/.abuild/$KEY_NAME -pubout \
                    -out /etc/apk/keys/${KEY_NAME}.pub
            
            # Build and sign the package (checksums already updated)
            abuild -r
            
            # Copy built packages
            outdir=/work/out
            mkdir -p "$outdir"
            find /home/*/packages -name "*.apk" -exec cp {} "$outdir"/ \;
            
            # Verify build output
            if [ ! "$(ls -A $outdir 2>/dev/null)" ]; then
              echo "No APK files were built"
              exit 1
            fi
            
            ls -la "$outdir"
          '

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.app_data.app }}-v${{ matrix.app_data.version }}-${{ matrix.arch }}
        path: ${{ matrix.app_data.app }}/out/*.apk
        retention-days: 30

  # Create GitHub releases
  create-releases:
    needs: [detect-updates, build-apks]
    if: needs.detect-updates.outputs.has_updates == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        include: ${{ fromJSON(needs.detect-updates.outputs.apps_matrix) }}
    
    steps:
    - name: Download artifacts for ${{ matrix.app }}
      uses: actions/download-artifact@v4
      with:
        pattern: ${{ matrix.app }}-v${{ matrix.version }}-*
        path: artifacts
        merge-multiple: true

    - name: List artifacts
      run: |
        echo "Downloaded artifacts for ${{ matrix.app }}:"
        find artifacts -name "*.apk" -ls

    - name: Create release for ${{ matrix.app }}
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ matrix.app }}-v${{ matrix.version }}
        name: "${{ matrix.app }} v${{ matrix.version }} for Alpine"
        body: |
          ## ${{ matrix.app }} v${{ matrix.version }}
          
          **${{ matrix.description }}**
          
          Alpine Linux APK packages for multiple architectures.
          
          ### Installation
          ```bash
          # Add the APK to your Alpine system
          apk add --allow-untrusted ${{ matrix.app }}-${{ matrix.version }}-r0.apk
          ```
          
          ### Architectures
          - x86_64 (Intel/AMD 64-bit)
          - aarch64 (ARM 64-bit)
          
          Built automatically from upstream release: https://github.com/${{ matrix.upstream }}/releases/tag/v${{ matrix.version }}
        files: artifacts/*.apk
        draft: false
        prerelease: false